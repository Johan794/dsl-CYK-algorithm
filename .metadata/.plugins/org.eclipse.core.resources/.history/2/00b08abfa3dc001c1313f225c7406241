/*
 * generated by Xtext 2.27.0-SNAPSHOT
 */
package org.xtext.cyk.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.cyk.mydsl.myFNC.GNFC
import java.util.ArrayList
import java.util.TreeMap

/**
 * Generates code from your model files on save.
 * this class has the responsibility of create the interaction between model and ui for xtext 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyFNCGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val grammar = resource.contents.head as GNFC
		fsa.generateFile('result.txt',runCYK(grammar))
	}
	
	def runCYK(GNFC grammar){
		var cyk = setCYK(grammar)
		'''
		«cyk.doSteps()»
		'''
		
	}
	
	def setCYK(GNFC grammar){
		var cyk = new CYK();
		cyk.word = grammar.final.input
		//string+=grammar.init.left
		cyk.setStartingSymbol(grammar.init.left)
		cyk.setNonTerminals(getNonTerminals(grammar))
		cyk.setTerminals(getTerminals(grammar))
		cyk.setGrammar(setGrammarData(grammar))
		
		
		cyk
	}
	
	def getNonTerminals(GNFC grammar){
		var nonTerminals = new ArrayList()
		for(production: grammar.productions){
			nonTerminals.add(production.left.^var)
		
		}
		nonTerminals;
	}
	
	def getTerminals(GNFC grammar){
		var terminals = new ArrayList()
		for(production: grammar.productions){
			for(rigth: production.rigth){
				 if(rigth.simple !== null){
						terminals.add(rigth.simple.^alpha)
				}	
			}
		}
		
		terminals // an array with all the terminals
		
	}
	
	def setGrammarData(GNFC grammar){
		var map = new TreeMap<String,ArrayList<String>>
		for(production: grammar.productions){
			map.put(production.left.^var,new ArrayList())
			for(rigth: production.rigth){
				 if(rigth.simple !== null){
					map.get(production.left.^var).add(rigth.simple.^alpha) 	
				 }else if(rigth.binary!==null){
				 	map.get(production.left.^var).add(rigth.binary.first.^var+rigth.binary.second.^var)
				 }
					
			}
		
		}
		
		
		map
	}
	
	
	
	
}
